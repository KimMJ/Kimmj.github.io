<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ubuntu on Ibiza</title><link>http://kimmj.github.io/ubuntu/</link><description>Recent content in Ubuntu on Ibiza</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 08 Jan 2020 01:51:33 +0900</lastBuildDate><atom:link href="http://kimmj.github.io/ubuntu/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux에서 압축파일 분할하기</title><link>http://kimmj.github.io/ubuntu/split-tgz/</link><pubDate>Sun, 06 Dec 2020 17:52:11 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/split-tgz/</guid><description>Linux 환경에서 압축파일을 분할하는 방법에 대해 알아볼 것이다.
Prerequisite tar binary installed split binary installed cat binary installed How to split 다음은 이번에 할 압축분할에 대한 간단한 flow 이다.
graph TD A[Files] --&amp;gt;|Compress with tar| B(tar output) B --&amp;gt; |Split file with split| C(splited files) C --&amp;gt; |Join splitted files with cat| D(single file) D --&amp;gt; |Express with tar| E(Files) Compress with tar 먼저 우리가 알고있는 일반적인 방법으로 압축을 하여 하나의 파일로 만든다.</description></item><item><title>Samba를 통한 디스크 공유</title><link>http://kimmj.github.io/ubuntu/samba/</link><pubDate>Sat, 28 Nov 2020 00:42:06 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/samba/</guid><description>Samba는 리눅스에 있는 폴더를 윈도우와 공유하기 위해 사용한다. 최초에 NFS로 구성했으나 NFS는 다음과 같은 문제점이 있었다.
폴더 전체를 rwx 권한을 주게 만들거나 nobody:nogroup으로 모든 권한을 폴더에 줘야 했다. perforce와 연동하려고 구성한 것이었는데 1번의 문제로 인해 자꾸 충돌이 발생했다. 이때문에 다른 대안을 찾던 중 samba를 알게 되었고, 이를 내 컴퓨터에도 적용해보았다.
Samba 구성 samba 설치 apt install samba -y samba 설정 /etc/samba/smb.conf 파일을 열어 수정한다.
[workspace] # 여기서 workspace는 접근할 때 사용되는 이름 comment = workspace path path = /path read only = no ritable = yes browseable = yes guest ok = yes available = yes public = yes valid users = root user 추가 실제 passwd에 등록된 계정으로 설정해야 한다.</description></item><item><title>Ubuntu의 Login Message 수정하기</title><link>http://kimmj.github.io/ubuntu/customize-login-message/</link><pubDate>Wed, 11 Mar 2020 14:20:42 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/customize-login-message/</guid><description>TLDR Expand me... This package seeks to make the /etc/motd (Message of the Day) more dynamic and valuable, by providing a simple, clean framework for defining scripts whose output will regularly be written to /etc/motd.
Ubuntu에서는 /etc/update-motd.d 안에 있는 파일들을 확인하여 console, ssh 등 어떤 방법으로든 로그인했을 때 메시지를 띄워줍니다. 여기서 파일들을 사전순으로 로딩하게 됩니다.
따라서 해당 폴더에 적절한 파일들을 생성하게 된다면 로그인 시 출력되는 메시지를 조작할 수 있습니다.</description></item><item><title>reboot 후에 tmux를 실행시켜 원하는 작업을 하기</title><link>http://kimmj.github.io/ubuntu/start-tmux-after-reboot/</link><pubDate>Sat, 29 Feb 2020 14:00:40 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/start-tmux-after-reboot/</guid><description>tmux는 terminal을 한 창에 여러개 띄울 때 사용하는 프로그램입니다.
이 프로그램의 특징은 detach 모드로 들어가면, 어디서든 terminal에 접속하여 해당 session에 접속했을 때, 그 화면 그대로를 가져올 수 있다는 것입니다.
즉, 원격 접속을 통해 서버에 접속했을 때 작업을 돌려놓고 detach모드로 들어가면 나의 session을 꺼도 실제 서버에서는 해당 작업이 계속해서 돌아가고 있다는 것입니다. 퇴근하기 전 시간이 오래걸리는 작업을 돌려놓고 가야할 때 유용하게 사용할 수 있습니다.
저의 경우는 제 로컬 컴퓨터에서 hugo를 통해 사이트를 생성하여 블로그를 편집할 때마다 즉시 그 결과를 보고 있습니다.</description></item><item><title>oh-my-zsh에서 home key와 end key가 안될 때 해결방법</title><link>http://kimmj.github.io/ubuntu/oh-my-zsh-home-end-key/</link><pubDate>Sat, 29 Feb 2020 02:27:25 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/oh-my-zsh-home-end-key/</guid><description>oh-my-zsh을 설치하고 원격접속이나 로컬환경에서 터미널에 접속했을 때 home key와 end key가 먹히지 않는 경우가 있습니다.
이런 경우에 사용하는 terminal에서 home key와 end key를 눌러 실제 어떤 값이 전달되는지 확인한 후, 이를 beginning-of-line, end-of-line으로 설정하면 해결할 수 있습니다.
해결법 home key가 되지 않는 terminal에 접속합니다. Control+V를 누릅니다. 문제가 되는 home key를 누릅니다. terminal에 뜬 문자를 기록합니다. ~/.zshrc에 다음과 같이 추가합니다. 여기서 case에 관한 부분은 상황에 따라 넣지 않거나 변경해야 합니다. case $TERM in (xterm*) bindkey &amp;#39;^[[H&amp;#39; beginning-of-line bindkey &amp;#39;^[[F&amp;#39; end-of-line esac source ~/.</description></item><item><title>Ubuntu에서 Base64로 인코딩, 디코딩하기</title><link>http://kimmj.github.io/ubuntu/base64-encode-decode/</link><pubDate>Thu, 27 Feb 2020 20:44:42 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/base64-encode-decode/</guid><description>Encode echo로 입력하기 $ echo &amp;#34;password&amp;#34; | base64 cGFzc3dvcmQK Control+D를 누를때까지 입력하기 $ base64 admin password ^D # Control+D # result YWRtaW4KcGFzc3dvcmQK Decode echo로 입력하기 $ echo &amp;#34;cGFzc3dvcmQK&amp;#34; | base64 --decode password Control+D를 누를때까지 입력하기 $ base64 --decode YWRtaW4KcGFzc3dvcmQK ^D # Control+D # result admin password</description></item><item><title>Editor(vi)가 없을 때 파일 수정하기</title><link>http://kimmj.github.io/ubuntu/file-edit-without-editor/</link><pubDate>Wed, 26 Feb 2020 17:59:29 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/file-edit-without-editor/</guid><description>echo로 파일 내용을 입력하는 방법 &amp;gt;로 파일 덮어쓰기 $ cat file asdfasdfasdf $ echo &amp;#34;asdf&amp;#34; &amp;gt; file $ cat file asdf &amp;gt;&amp;gt;로 파일에 이어쓰기 $ cat file asdf $ echo &amp;#34;asdf&amp;#34; &amp;gt;&amp;gt; file $ cat file asdf asdf cat으로 파일 입력하는 방법 &amp;gt;로 파일 덮어쓰기 $ cat file asdf $ cat &amp;gt; file aaaa bbbb ^D # Command+D $ cat file aaaa bbbb &amp;gt;&amp;gt;로 파일에 이어쓰기 $ cat file asdf $ cat &amp;gt;&amp;gt; file aaaa bbbb ^D # Command+D $ cat file asdf aaaa bbbb &amp;laquo;EOF로 EOF을 입력하면 입력 완료하기 $ cat file asdf $ cat &amp;lt;&amp;lt;EOF &amp;gt; file aaaa bbbb EOF $ cat file asdf aaaa bbbb</description></item><item><title>열려있는 포트 확인하기</title><link>http://kimmj.github.io/ubuntu/check-listen-port/</link><pubDate>Mon, 24 Feb 2020 13:38:04 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/check-listen-port/</guid><description>열려있는 포트 확인하기 # 방법 1 lsof -i -nP | grep LISTEN | awk &amp;#39;{print $(NF-1)&amp;#34; &amp;#34; $1}&amp;#39; | sort -u # 방법 2 netstat -tnlp 열려있는 포트 확인하기 + 관련된 프로세스 이름 확인하기 netstat -tnlp | grep -v 127.0.0.1 | sed &amp;#39;s/:::/0 /g&amp;#39; | sed &amp;#39;s/[:\/]/ /g&amp;#39; | awk &amp;#39;{print $5&amp;#34;\t&amp;#34;$10}&amp;#39; | sort -ug</description></item><item><title>pipe를 사용한 명령어를 watch로 확인하기</title><link>http://kimmj.github.io/ubuntu/using-watch-with-pipes/</link><pubDate>Sun, 23 Feb 2020 16:07:38 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/using-watch-with-pipes/</guid><description>pipe(|)는 grep과 다른 기타 명령어들과 함께 사용하면 좀 더 다양한 작업을 할 수 있습니다.
watch는 특정 명령어를 주기적으로 입력하여 결과 메시지를 확인합니다. 즉, 무엇인가를 모니터링할 때 주로 사용하곤 합니다.
바로 본론으로 들어가서 pipe를 사용한 명령어를 watch로 확인하는 방법은 다음과 같습니다.
watch &amp;#39;&amp;lt;command&amp;gt;&amp;#39; 위와같이 quote로 감싸주세요.
ls -al을 가지고 확인해 보도록 하겠습니다.
$ ls -al | grep config -rw-rw-r-- 1 wanderlust wanderlust 2.9K 1월 21 23:40 config.toml $ watch ls -al | grep config # quote를 사용하지 않은 것 ^C # 결과 출력되지 않음 $ watch &amp;#34;ls -al | grep config&amp;#34; Every 2.</description></item><item><title>watch를 사용할 때 alias 이용하기</title><link>http://kimmj.github.io/ubuntu/use-alias-in-watch/</link><pubDate>Sat, 22 Feb 2020 23:33:02 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/use-alias-in-watch/</guid><description>watch는 정해진 시간동안 뒤에 적은 명령어를 실행해주는 프로그램입니다. 가령 kubernetes를 다룰 때 watch kubectl get pods -n kube-system을 통해 kube-system 네임스페이스에 있는 파드들을 지속적으로 모니터링 할 수 있습니다.
그러나 watch는 alias된 명령어를 인식하지 못합니다.
$ ll total 44K drwxrwxr-x 2 wanderlust wanderlust 4.0K 1월 7 20:38 archetypes -rw-rw-r-- 1 wanderlust wanderlust 2.9K 1월 21 23:40 config.toml drwxrwxr-x 16 wanderlust wanderlust 4.0K 2월 22 23:08 content $ watch ll Every 2.0s: ll sh: 1: ll: not found 이 때 해결할 수 있는 가장 편한 방법은 watch 자체를 alias 시켜버리는 것입니다.</description></item><item><title>password 없이 ssh 접속하기</title><link>http://kimmj.github.io/ubuntu/ssh-without-password/</link><pubDate>Sat, 15 Feb 2020 15:48:57 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/ssh-without-password/</guid><description>자주 접속하는 서버에 패스워드를 항상 입력하는 것은 귀찮은 일이 될 것입니다.
여기에서는 ssh key를 생성하고, 이를 이용하여 인증을 해 password를 입력하지 않는 방법을 알아볼 것입니다.
ssh-keygen을 통한 ssh key 생성 ssh 접속을 할 때 password를 입력했던 것처럼, 항상 ssh 접속을 위해서는 인증을 위한 key가 필요합니다.
인증에 사용할 키를 ssh-keygen으로 생성하는 방법은 다음과 같습니다.
ssh-keygen -t rsa -b 4096 -t는 rsa 알고리즘을 통해 key를 생성하겠다는 의미이며, -b는 key의 사이즈를 정해주는 것입니다.</description></item><item><title>SSH Tunneling 사용법</title><link>http://kimmj.github.io/ubuntu/ssh-tunneling/</link><pubDate>Thu, 13 Feb 2020 21:16:02 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/ssh-tunneling/</guid><description>-D 옵션으로 socks proxy 사용하기 A라는 서버에서 B라는 서버에 있는 서비스를 보려고 합니다. 이 때, 해당 웹 어플리케이션은 B에서만 연결된 특정 IP로 통신을 하고 있고, 이 때문에 A에서 어플케이션이 제대로 동작하지 않는 상황입니다.
이 때 사용할 수 있는 것이 -D 옵션입니다.
예시
ssh -D 12345 user@server.com 해당 세션이 꺼져있지 않은 상태에서 A 서버에서 웹 브라우저가 localhost:12345를 프록시로 사용하도록 하면 해당 웹 어플리케이션이 제대로 동작합니다.
만약 windows라면 다음과 같이 진행하면 socks proxy를 사용하도록 할 수 있습니다.</description></item><item><title>Gateway를 이용하여 SSH 접속하기</title><link>http://kimmj.github.io/ubuntu/ssh-with-jump/</link><pubDate>Wed, 12 Feb 2020 22:08:16 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/ssh-with-jump/</guid><description>ssh cli 이용하는 방법 -J 옵션을 이용한다.
ssh user@server -J user2@server2 두개 이상의 경우 ,로 구분한다.
예: user2@server2로 접속 후 user3@server3로 접속한 뒤 user@server로 접속해야 할 경우
ssh user@server -J user2@server2,user3@server3 이 상황에서 ssh-copy-id를 이용해 패스워드를 입력하지 않고 이동하려면
localuser@localhost $ ssh-copy-id user2@server2 localuser@localhost $ ssh user2@server2 user2@server2 $ ssh-copy-id user3@server3 user2@server2 $ ssh user3@server3 user3@server3 $ ssh-copy-id user@server 이후 ssh를 통해 진입하면 패스워드 없이 접속 가능.
만약 port가 필요한 경우 server:port 형태로 입력</description></item><item><title>Hostname 변경하기</title><link>http://kimmj.github.io/ubuntu/change-hostname/</link><pubDate>Tue, 14 Jan 2020 01:00:02 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/change-hostname/</guid><description>hostname을 바꾸는 일은 흔치 않지만 최초 셋업할 때 많이 사용하곤 합니다.
# hostnamectl set-hostname &amp;lt;host name&amp;gt; hostnamectl set-hostname wonderland 변경 후 터미널을 끄고 재접속을 하면 변경된 사항을 볼 수 있습니다.
hostname</description></item><item><title>추가 입력절차(prompt) 없이 Ubuntu 설치하는 이미지 만들기</title><link>http://kimmj.github.io/ubuntu/unattended-ubuntu/</link><pubDate>Wed, 08 Jan 2020 01:52:32 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/unattended-ubuntu/</guid><description>어디에 좋을까 Ubuntu Server를 설치하기 위해서는 많은 추가 입력이 있어야 합니다. 사용자가 어떻게 설치하기를 원하는지 모르기 때문에, 또 다양한 옵션을 사용자가 선택하기 위해서는 어찌보면 당연한 것이겠지요. 하지만 만약 똑같은 설정을 사용할 것인데, 여러대의 서버에 OS를 설치하는 상황이라고 생각해보면 정말 암울합니다. 온전히 시간을 OS 설치에만 투자하자니 이건 간단한 업무로 인해 다른 업무를 보지 못하게 됩니다. 또 다른 업무와 동시에 하자니 다음 입력창이 뜰 때인지 한번씩 확인해 주어야 합니다.
따라서 어차피 같은 설정을 한다면, 이러한 설정을 미리 해 놓는 방법이 Ubuntu iso 파일 내부에 있을 것이라고 추측했습니다.</description></item><item><title>Ubuntu 설치 시 Boot Parameter를 수정하기</title><link>http://kimmj.github.io/ubuntu/how-to-edit-boot-parameter-during-install/</link><pubDate>Wed, 08 Jan 2020 01:52:12 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/how-to-edit-boot-parameter-during-install/</guid><description>Ubuntu 설치할 때 boot parameter가 필요한 상황이 간혹 발생할 수 있습니다.
특히 저의 경우, preseed.cfg를 수정하기 위해 인스톨러가 질의하는 것이 preseed.cfg의 어떤것과 대응이 되는지를 보기 위해 DEBCONF_DEBUG=5라는 옵션을 boot parameter로 주어야 했습니다. 이 때 사용할 수 있는 방법을 소개드립니다.
먼저 평소와 같이 ubuntu를 설치하기 위해 설치 이미지를 삽입합니다. 그 다음에는 언어를 선택하시면, 다음으로 넘어가기 전에 메뉴가 뜹니다.
이 상태에서 F6을 누르시면 옵션을 선택할 수 있고, 이 때 ESC키를 누르면 boot parameter가 하단에 보일 것입니다.</description></item><item><title>sudo를 password 없이 사용하기</title><link>http://kimmj.github.io/ubuntu/how-to-use-sudo-without-password/</link><pubDate>Wed, 08 Jan 2020 01:51:54 +0900</pubDate><guid>http://kimmj.github.io/ubuntu/how-to-use-sudo-without-password/</guid><description>/etc/sudoers는 sudo를 사용할 수 있는 파일입니다. 이 파일을 열어보면 다음과 같은 글이 적혀 있습니다.
Please consider adding local content in /etc/sudoers.d/ instead of directly modifying this file
즉, 직접 이 파일을 수정해서 sudo 권한을 주지 말고, /etc/sudoers.d/ 폴더 내에 파일을 추가하라는 의미입니다.
이 곳에는 /etc/sudoers와 마찬가지로 계정에 대한 설정을 추가할 수 있습니다. 그리고 /etc/sudoers에서는 &amp;ldquo;NOPASSWD&amp;quot;라는 옵션을 주어 password없이 타 계정의 권한을 가지게 만들 수 있습니다.
이 두가지를 종합하여 내 linux 계정이 sudo 명령어를 입력할 때, 즉 root 권한을 가지게 될 때 password를 입력하지 않도록 설정할 수 있습니다.</description></item></channel></rss>