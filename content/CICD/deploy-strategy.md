---
title: "Deploy Strategy"
menuTitle: "Deploy Strategy"
date:  2020-02-03T14:09:25+09:00
weight: 10
draft: false
tags: ["deploy", "cicd", "canary", "blue-green", "roll-out"]
pre: "<i class='fas fa-minus'></i>&nbsp;"
---

## Deploy Strategy

실제 시스템을 운용할 때 중요하게 여겨지는 것 중 하나가 downtime을 없애는 것이다.
새로운 업데이트가 있을 때마다 해당 인스턴스가 동작하지 않는다면, 자주 업데이트 하는 것이 어려워질 수 있습니다.
따라서 deploy strategy를 가지고 어떻게 downtime을 줄이는지 알아보도록 하겠습니다.

## Canary

`canary deploy`는 **트래픽 비율을 바꾸어가며 배포하는 전략**입니다.
이해하기 편하도록 Kubernetes 환경이라고 생각해 보도록 하겠습니다.
(또는 LoadBalancer가 있어서 부하를 분산하고 있다고 생각하면 좋을 것 같습니다.)
이 때 업데이트된 버전을 따로 올리고 트래픽을 `old:new = 100:0`으로 줍니다.
이러면 새로운 버전이 정상적으로 실행할 준비가 될 때까지는 우리의 인스턴스가 정상적으로 동작하고 있을 것입니다.

준비가 되었다면, `old:new = 90:10`처럼 약간의 트래픽을 새로운 버전으로 흘려줍니다.
이 어플리케이션이 만약 웹사이트라면, 전체 유저 중 10%의 사람만이 새로운 버전의 웹사이트를 보게 될 것입니다.

이 때 각종 통계라던지 테스트를 통해 새로운 버전에 문제가 없는지 확인합니다.
혹시나 문제가 발생하더라도, 10%의 사람만이 문제를 경험하게 될 것입니다.
문제점이 발견되면 다시 `old:new = 100:0`으로 트래픽을 돌려버리면 이전의 잘 돌아가던 상태로 복구할 수 있습니다.

이런식으로 새로운 버전의 트래픽을 능동적으로 조금씩 늘려가며 여러 지표를 확인하고 정상적이라고 판단되면 `old:new = 0:100`으로 변경합니다.
그 다음 이전 버전을 삭제하면 이제 완전히 새로운 버전으로 업데이트 된 것입니다.

이 방식은 특정 부분을 운용중에 긴급 패치하는 경우 사용할 수 있는 전략입니다.
장애가 발생하더라도 큰 위험 부담이 없기 때문이죠.

그러나 이를 위해서는 새로운 버전이 얼마나 이전 버전과 호환이 잘 되는지가 중요합니다.
만약 이전 버전과는 너무나도 다른 새로운 버전이 있다면 전체 어플리케이션은 정상적으로 동작하지 않을 수 있습니다.

|![canary-0](/images/CICD/canary-0.png)|![canary-1](/images/CICD/canary-1.png)|![canary-2](/images/CICD/canary-2.png)|![canary-3](/images/CICD/canary-3.png)|![canary-4](/images/CICD/canary-4.png)|![canary-5](/images/CICD/canary-5.png)|
|---|---|---|---|---|---|---|

## Blue-Green

`blue-green deploy`는 **두개의 버전을 동시에 올려놓고, 트래픽을 한번에 바꾸는 전략**입니다.

하나의 인스턴스에 대해 버전을 두가지 올립니다.
이 때, 트래픽의 비율은 `old:new = 100:0`으로 항상 이전 버전으로만 흐르도록 합니다.
그러다가 어느 순간 `old:new = 0:100`으로 트래픽을 아예 바꾸어버립니다.
그러면 유저는 항상 새로운 버전만 경험하게 될 것입니다.

이렇게 새로운 버전을 운용하며 문제점을 파악합니다.
`canary`와는 다르게 문제점이 있을 경우 해당 인스턴스가 아예 중단되어 downtime이 생깁니다.
이럴 때에는 다시 원래대로 트래픽을 `old:new = 100:0`으로 바꾸면 이전 버전으로 빠르게 roll back이 가능합니다.

또한 `canary`에서는 긴급 패치하는 경우, 하나의 인스턴스에 대해서만 행해진다고 하였습니다.
그러나 `blue-green`의 경우 전체 패키지 또는 어플리케이션에 대해서도 사용할 수 있는 전략입니다.
물론 장비가 2배로 들겠지만, 트래픽만 바꾸면 되니 빠른 roll back이 가능하기 때문에 그 비용을 감수할 수 있습니다.

당연하게도 하나의 인스턴스만 업데이트하는 경우에도 사용할 수 있습니다.
이 경우에는 다른 인스턴스들과 잘 호환이 되어야 합니다.
반면 전체 어플리케이션에 대해 할 경우 함께 설치되는 인스턴스들끼리의 호환성만 확인하면 됩니다.
dependency가 복잡할 경우, 어플리케이션이 빠르게 변화하는 경우 사용해볼 수 있을 것입니다.

|![blue-green-0](/images/CICD/blue-green-0.png)|![blue-green-1](/images/CICD/blue-green-1.png)|![blue-green-2](/images/CICD/blue-green-2.png)|![blue-green-3](/images/CICD/blue-green-3.png)|
|---|---|---|---|

## roll out

`roll out`은 하나의 인스턴스에 대해 Pod 또는 VM이 여러개 떠있다고 가정합니다.

이 때, 하나씩 순차적으로 새로운 버전으로 변경합니다.
downtime을 줄이고 싶다면 업데이트하는 동안에는 트래픽을 흐르지 않도록 하면 될 것입니다.

이런식으로 순차적으로 새로운 버전으로 변경하여 최종적으로는 모든 노드에 대해 업데이트가 완료될 것입니다.

`canary`와 마찬가지로 다른 버전의 인스턴스들과 잘 동작해야함을 보장해야 합니다.
그래야 두 버전이 동시에 사용되고 있다고 하더라도 정상적으로 어플리케이션이 동작하게 될 것입니다.

|![roll-out-0](/images/CICD/roll-out-0.png)|![roll-out-1](/images/CICD/roll-out-1.png)|![roll-out-2](/images/CICD/roll-out-2.png)|![roll-out-3](/images/CICD/roll-out-3.png)|
|---|---|---|---|
