<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kubernetes on Ibiza</title><link>http://kimmj.github.io/tags/kubernetes/</link><description>Recent content in kubernetes on Ibiza</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 10 Feb 2021 16:18:17 +0900</lastBuildDate><atom:link href="http://kimmj.github.io/tags/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>Controllers Overview</title><link>http://kimmj.github.io/kubernetes/concepts/controllers-overview/</link><pubDate>Thu, 30 Jan 2020 18:26:04 +0900</pubDate><guid>http://kimmj.github.io/kubernetes/concepts/controllers-overview/</guid><description>Contents 이 포스트에서는 Kubernetes의 Controller들에 대해서 알아보도록 하겠습니다. 가장 작은 단위인 Container부터, 상위 개념인 Deployment, StatefulSet까지 다루어 보도록 하겠습니다.
Containers Pods ReplicaSets Deployments StatefulSets Monolithic vs. Microservice 우선 Monolithic과 Microservice에 대해서 짚고 넘어가도록 하겠습니다.
Monolithic의 개념은 하나의 큰 어플리케이션을 말합니다. 여러 사람이 개발을 하고 나서 하나의 큰 패키지로 빌드하고 이를 배포하죠. 간단한 서비스라면 문제가 발생하지는 않겠지만, 점점 코드의 수가 늘어나고 거대해질 수록 문제점이 생깁니다. 예를 들면 빌드시간이 오래걸린다던지, scale-out을 하기 힘들다던지 하는 문제가 있겠네요.</description></item><item><title>Kubernetes Service는 어떻게 iptables 설정이 되는가</title><link>http://kimmj.github.io/kubernetes/kubernetes-service-iptables/</link><pubDate>Wed, 10 Feb 2021 16:18:17 +0900</pubDate><guid>http://kimmj.github.io/kubernetes/kubernetes-service-iptables/</guid><description>kube-proxy 는 daemonset 으로 각각의 노드에 모두 떠있다. 역할은 kubernetes에서의 service 가 가지고 있는 Virtual IP 로 트래픽을 전달할 수 있도록 적절한 조작을 해주는 것이다. 기본적으로 3가지 모드가 있으나, 일반적으로는 iptables 모드를 많이 사용한다.
User space
iptables
Linux Kernel 에서의 netfilter 를 사용하여 kubernetes 서비스에 대한 라우팅을 설정하는 것이다. 이 모드가 default 옵션이다. 여러개의 pod 로 트래픽을 load balancing 할 때 unweighted round-robin scheduling 을 사용한다.</description></item><item><title>Kubernetes Components</title><link>http://kimmj.github.io/kubernetes/concepts/kubernetes-components/</link><pubDate>Tue, 09 Feb 2021 17:29:15 +0900</pubDate><guid>http://kimmj.github.io/kubernetes/concepts/kubernetes-components/</guid><description>각 Components 에 대해 알아보자.
Control Plane Component ETCD partition tolerance(분할 내성)보다 consistency(일관성)에 중점을 둔 db. ETCD 는 간단한 unstructured value를 저장하기에 좋다.
consistency를 중요하게 여기기 때문에 write의 순서를 엄격하게 규정하여 set value 시 atomic한 update를 제공한다.
client는 특정한 key namespace에 대해 subcription을 하여 변화를 감지할 수 있다. 따라서 어떤 component가 ETCD에 write를 할 경우 다른 component는 즉각적으로 그 변화에 대응할 수 있다.
kube-apiserver Kubernetes에서 ETCD와 통신하는 유일한 시스템이다. ETCD로의 접근 시도에 대해 필터링을 한다.</description></item><item><title>Kubernetes에서의 cpu requests, cpu limits는 어떻게 적용될까</title><link>http://kimmj.github.io/kubernetes/kubernetes-cpu-request-limit/</link><pubDate>Tue, 22 Dec 2020 02:02:49 +0900</pubDate><guid>http://kimmj.github.io/kubernetes/kubernetes-cpu-request-limit/</guid><description>Kubernetes 에서는 컨테이너 단위로 resource를 할당할 수 있다. 여기에는 memory, cpu, ephemeral-storage, hugepages 등이 포함된다. 이 중에서 cpu 의 requests, limits 가 어떤 방식으로 적용이 되는지에 대해 알아볼 것이다.
Linux Kernel 먼저 기본적으로 Kubernetes는 Linux Kernel의 cgroup을 사용하여 리소스 할당을 한다. cgroup은 control groups 의 의미를 가지며 프로세서들의 자원(cpu, memory 등)을 제한하는 기술이다.
CPU Share cpu.shares는 CPU를 다른 group에 비해 상대적으로 얼마나 사용할 수 있는지를 나타내는 값이다. 예를 들어 하나의 CPU를 가지고 있고, 두개의 group이 있다고 해보자.</description></item><item><title>[번역] 쿠버네티스에서의 Port, TargetPort, NodePort</title><link>http://kimmj.github.io/kubernetes/port-targetport-nodeport-in-kubernetes/</link><pubDate>Sun, 15 Mar 2020 23:13:37 +0900</pubDate><guid>http://kimmj.github.io/kubernetes/port-targetport-nodeport-in-kubernetes/</guid><description>원문: https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-ports-targetport-nodeport-service.html
쿠버네티스의 port declaration 필드에는 여러가지가 있다. 각 type에 대해 빠르게 살펴보고 YAML에서 각각 어떤 의미를 가지고 있는지 알아보도록 하자.
Pod ports list pod.spec.containers[].ports로 정의된 이 배열은 container가 노출하고 있는 포트의 리스트를 나타낸다. 이 리스트를 꼭 작성해야할 필요는 없다. 리스트가 비어있다고 하더라도 container가 포트를 listening하고 있는 한 여전히 네트워크 접속이 가능하다. 이는 단순히 쿠버네티스에게 추가적인 정보를 줄 뿐이다.
List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational.</description></item><item><title>Stern을 이용하여 여러 pod의 log를 한번에 확인하기</title><link>http://kimmj.github.io/kubernetes/stern/</link><pubDate>Mon, 24 Feb 2020 23:28:01 +0900</pubDate><guid>http://kimmj.github.io/kubernetes/stern/</guid><description>Kubernetes에서의 trouble shooting kubernetes 환경에서 어떤 문제가 발생하면 다음과 같은 flow로 확인을 해보면 됩니다.
kubectl get pods -o yaml로 yaml을 확인하기 kubectl describe pods로 pod에 대한 설명 확인하기 kubectl describe deployments(statefulset, daemonset)으로 확인하기 kubectl logs로 로그 확인하기 보통 kubernetes 리소스의 부족과 같은 kubernetes단의 문제는 1~3을 확인하면 전부 문제점을 찾을 수 있습니다. 그러나 어플리케이션의 직접적인 원인을 알아보기 위해서는 log를 확인해야 합니다.
하지만 kubectl의 logs에는 한가지 한계점이 있는데, 바로 단일 container에 대해서만 log 확인이 가능하다는 점입니다.</description></item><item><title>Pods</title><link>http://kimmj.github.io/kubernetes/concepts/pods/</link><pubDate>Mon, 03 Feb 2020 14:03:50 +0900</pubDate><guid>http://kimmj.github.io/kubernetes/concepts/pods/</guid><description>Pod Overview Pod의 이해 Pod는 Kubernetes에서 가장 작은 배포 오브젝트이며 쿠버네티스에서 관리하는 최소 관리 단위입니다. Pod는 cluster 안에서 실행중인 어떤 프로세스를 의미합니다. application container, 스토리지 리소스, 유일한 network ip, container가 어떻게 실행할지를 캡슐화한 것입니다.
각각의 Pod는 주어진 application에서 단일 인스턴스를 수행합니다. 즉, 한가지 역할을 맡고 있다고 생각하시면 됩니다.. 따라서 application을 수직확장하고 싶다면 각 인스턴스에 대해 여러 Pod를 생성하면 된다. 그러면 동일한 역할을 하는 Pod가 늘어나니, 병렬적으로 처리가 가능할 것입니다.
Pod는 서비스 중에서 서로 연관성이 높은 프로세스를 지원하기 위해 디자인되었습니다.</description></item></channel></rss>